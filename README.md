# O-O-wl 's Standard  🦉📖

---

나만의 기준을 찾아가는 중

---

#### 고쳐야할 문제점
 - 의문이 드는 것에 대한 탐색은 하나, 당연하지 않을 걸 당연하게 생각하는 게 꽤 있고, 그래서 궁금증조차 가지지 않는 경우가 많다
 - 좋다고 한 번 느끼면 꽤나 맹신한다.
 - 여러 선택지에서 좋는 답을 찾을 때, 감각에 의존하거나 이전에 비슷한 사례를 보고 결정을 하나, 그 사례에서 왜 이런 선택을 했는 지가 명확하지 않은 적이 많다 
<br>

<br>

## 나의 기준

---

- #### 클래스

<br>

- #### 열거형

  - 클래스내에 nested enum으로 정의하는 경우 - 확장 또는 프로퍼티 위에 위치하게 하자. 
    - 케이스가 5개 이상인  enum일 경우 확장을 하자.
  - 제한된 갯수의 케이스만 존재할 경우 enum 을 생각해보자
  - 

<br>

- #### 구조체

<br>

- #### 프로토콜



- ### 익스텐션

  - 기본 자료형을 핸들링하는 메소드가 어떤 객체에서 필요하나, 객체내부에 구현하면 응집도가 떨어지는 경우 고려해볼 수 있다.
  - 

<br>

- #### 제네릭

<br>

- #### 옵셔널

  - **강제 옵셔널 언래핑**은 변수에서는 사용하지 말자. 상수 또는 하드코딩된 보장할 수있는 값 에서만 사용하자.

  - ``` 
    변수는 어디서 값이 정해지는 지 또 어디서 변하는 지 모호하다. 상수로 된 값이나 리터럴은 이걸 보장할 수 있다.
    ```

  - 옵셔널이 아닌 무조건 존재해야하는 값을 옵셔널로 하는 걸 기피하자.

  - ```
    옵셔널 이라는 건 값이 존재할 수 있고 아닐 수 있다는 걸 의미한다. 그 말은 언옵셔널한 데이터는 무조건 값이 존재한다는 걸 의미한다. 무조건 값이 존재한다는 건 데이터의 무결성을 보여주는 것이다. 
    무결함을 보여야 할 객체와 nilable 한 객체를 확실히 구분하기 위해 노력하자.
    ```

  - **IUO** 언제 사용??
  
    - 일반 옵셔널과 목적이 다르다. 꼭 준비되야한다는 의도를 표현할 수있다.
    - 상위 모듈의 생성시에는 초기화 안될수 있지만, 사용시에는 꼭 초기회되야한다는 걸 명시할 수있다.
    - 

<br>

---

<br><br>

## 나쁜 습관과 피해야할 코드

---



- ### 클래스

  - 내부에서 다른 클래스와 구조체의 생성자를 호출하지말자

    ```
    생성자는 구체적인 타입에 의존하는 코드이고, 외부에 의존성이 숨어서 테스트도 힘든 구조가 된다.
    ```

    

<br>

<br>

## 고민해야 하는 문제

---

- #### `computed property` vs `method`

  - 

- #### `struct` vs `class`

  - 

- #### `if`  vs `guard` 

  - 

- #### 객체내 타입 표현 vs 익스텐션을 통한 타입 표현



- #### `lazy property`  vs `eager property`

  - 해당 프로퍼티의 사용이 무조건적이지 않다면  `lazy`를 고민해보자
  - 객체를 생성하는 데 걸리는 오버헤드가 존재한다.  **객체가 쓰일 상황에 즉각적인 응답을 원한다면  `lazy`를 사용하지말자**

  
- #### `다양한 인스턴스` vs `클래스의 상속`

  - 상위 클래스에서 모든 인스턴스를 표현하는 속성이 아니라면 특수화된 서브클래스를 만들자.

- ####  `Enum` vs `Protocol`

  - 타입의 추가가 있을 상황? - **프로토콜**
    - 열거형은 `case` 가 추가되면 `switch` 문이 모두 고장나버리고 만다.
  - 함수의 추가가 지속적으로 있을 상황? - **열거형**
    - 함수의 추가가 있을 때, 프로토콜을 채택한 타입의 고장나고, 메소드의 구현이 요구된다.

- #### `throw Error` vs `optional`

  - **옵셔널**은 `nil 가능성을 의미한다`. 대신 nil의 이유를 표현하지는 않는다.

    - 옵셔널로 표현할 떄는 클라이언트가 nil이 반환된 이유를 명확히 알 수있어야한다. - 이유가 1개여야?
    - 만약 여러개의 이유로 nil이 반환된다면 옵셔널 보다는 Error로 실패이유를 설명하자

  - **Error Throw** 는 심각한 위험을 표현한다

    - 기존에 정상적인 흐름과는 다른 흐름으로 흐름제어가 일어나야하는 경우가 생긴다.

    

---

## 혼자만의 생각 정립하기

- #### 캡슐화 왜 해야돼?

