# O-O-wl 's Standard  🦉📖

---

나만의 기준을 찾아가는 중

---

#### 고쳐야할 문제점
 - 의문이 드는 것에 대한 탐색은 하나, 당연하지 않을 걸 당연하게 생각하는 게 꽤 있고, 그래서 궁금증조차 가지지 않는 경우가 많다
 - 좋다고 한 번 느끼면 꽤나 맹신한다.
 - 여러 선택지에서 좋는 답을 찾을 때, 감각에 의존하거나 이전에 비슷한 사례를 보고 결정을 하나, 그 사례에서 왜 이런 선택을 했는 지가 명확하지 않은 적이 많다 
<br>

<br>

## 나의 기준

---

- #### 클래스

<br>

- #### 열거형

<br>

- #### 구조체

<br>

- #### 프로토콜

<br>

- #### 제네릭

<br>

- #### 옵셔널

  - **강제 옵셔널 언래핑**은 변수에서는 사용하지 말자. 상수 또는 하드코딩된 보장할 수있는 값 에서만 사용하자.

  - ``` 
    변수는 어디서 값이 정해지는 지 또 어디서 변하는 지 모호하다. 상수로 된 값이나 리터럴은 이걸 보장할 수 있다.
    ```

  - 옵셔널이 아닌 무조건 존재해야하는 값을 옵셔널로 하는 걸 기피하자.

  - ```
    옵셔널 이라는 건 값이 존재할 수 있고 아닐 수 있다는 걸 의미한다. 그 말은 언옵셔널한 데이터는 무조건 값이 존재한다는 걸 의미한다. 무조건 값이 존재한다는 건 데이터의 무결성을 보여주는 것이다. 
    무결함을 보여야 할 객체와 nilable 한 객체를 확실히 구분하기 위해 노력하자.
    ```

  - 

<br>

---

<br><br>

## 나쁜 습관과 피해야할 코드

---



- ### 클래스

  - 내부에서 다른 클래스와 구조체의 생성자를 호출하지말자

    ```
    생성자는 구체적인 타입에 의존하는 코드이고, 외부에 의존성이 숨어서 테스트도 힘든 구조가 된다.
    ```

    

<br>

<br>

## 고민해야 하는 문제

---

- #### `computed property` vs `method`

  - 

- #### `struct` vs `class`

  - 

- #### `if`  vs `guard` 

  - 

- #### 객체내 타입 표현 vs 익스텐션을 통한 타입 표현



- #### `lazy property`  vs `eager property`

  - 해당 프로퍼티의 사용이 무조건적이지 않다면  `lazy`를 고민해보자
  - 객체를 생성하는 데 걸리는 오버헤드가 존재한다.  **객체가 쓰일 상황에 즉각적인 응답을 원한다면  `lazy`를 사용하지말자**

  
