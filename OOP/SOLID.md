# SOLID - 객체 지향 5 원칙

---

### 나쁜설계는 변경에 취약한 소프트웨어를 만든다

나쁜소프트웨어는 디른 곳에 영향을 주어서 A기능 수정이 B기능까지 영향을 주어 , 갑자기 엉뚱한 곳이 망가질 수있고 , 

그에 따른 연쇄되는 수정이 동반되어야 할것이다.

또 서로 연관 없는 코드들이 결합되어 있기 떄문에 , 하나를 재사용하려고 해도 , 그에 관련된 코드들을 줄줄이 사용하지 않으면 시스템에 문제가 생길 것이다.

또 한 곳에서 동작이 이리저리 퍼지고 , 또 한곳에서 여러동작을 하게 되면 메소드의 이름도 모호해지고 , 하는 일도 명확해지지 않게 될 것이다.

이런 코드를 **스파게티 코드** 라고 부른다 . 

이리저리 서로 얽히고 설켜서 , 끔찍한 코드를 보게 될 것이다 . 

이 문제를 해결하기위한 많은 무기들이 있다 .

**인터페이스,다형성**이라는 무기로 이 문제를 해결할 수 있을것 이다.



### 대부분은 의존관계 때문이야

이런 문제의 대부분은 의존 관계의 때문이다. 

관계없는 코드들이 서로 의존하게되면 **결합도**가  증가하게 된다. 또 , 쓸데없는 코드가 서로 관련된 코드에 껴 들어가게 되는 과정에서 **응집도** 는 낮아질 수 밖에 없다.

## 좋은 코드는 응집도가 높고 , 결합도가 낮다



```
나 자신을 라이브러리 배포자로 생각해보면 , 내가 만든 라이브러리를 배포하고 , 그걸 다른 사용자가 사용할 것이다.

내 라이브러리에 추가를 할 수도 있고, 기존코드의 변경이 있을 수 있다.

그 과정에서 기존의 라이브러리로 작성했던 다른 사용자들의 코드들이 부서질 수도 있다.

이 문제를 최소화 하기 위해서 SOLID 원칙을 지키려는 노력을 하다보면 , 조금 더 이후의 변경에 대해 안전한 라이브러리를 배포 할 수 있을 것이다 .

배포자의 입장으로 , 이걸 사용하는 사용자들의 불편함을 덜어주기위한 코드를 작성한다고 생각하면서 임해보자.

```



---

##SRP - **단일 책임 원칙** **(Single responsibility principle)**

하나의 클래스는 하나의 책임을 가져야한다.

클래스내부의 코드들은 서로 강하게 결합이 되게된다 . 두개의 서로 다른 책임을 가지게 된다면 , 서로 관련성이 없는 두 코드들이 강하게 결합될 수 있는 것이다.

또 , 여러개의 책임을 가지고 있다면 , 변경에 따른 테스트의 갯수 또한 많아지게 될 것이다.



- ### 여러개의 책임을 가진 구조체

```swift
struct IT기업 {
  
    func 소프트웨어만들기() -> 검증된소프트웨어? {
        let 설계도 = 설계하기()
        let 프로토타입 = 개발하기(설계도: 설계도)
        let 시제품 = 테스트하기(대상: 프로토타입) ? 프로토타입 : nil
        return 시제품
    }
    
    func 설계하기() -> 시스템다이어그램 {
      return 시스템다이어그램()
    }
    
    func 개발하기(설계도:시스템다이어그램) -> 소프트웨어 {
        return 소프트웨어()
    }
    
    func 테스트하기( 대상: 소프트웨어) -> Bool {
        return 소프트웨어.성능 > 50 ? true : false
    }
}
```

IT기업이 주체가되어 `설계하기`,`개발하기`, `테스트하기` 과정을 거쳐서 소프트웨어를 만들어 내고 있습니다

IT기업은 너무 많은 책임을 가지고 있습니다. 

수정에 따른 잦은파 일의 변경도 예상됩니다. 



- ### 단일 책임을 가지는 구조체

```swift
struct 좋은IT기업 {
    let 설계자: 설계자
    let 개발자: 개발자
    let 테스터: 테스터
    
    func 소프트웨어만들기() -> 검증된소프트웨어? {
        let 설계도 = self.설계자.설계하기()
        let 프로토타입 = self.개발하기(설계도: 설계도)
        let 시제품 = self.테스터.테스트하기(대상: 프로토타입) ? 프로토타입 : nil
        return 시제품
    }
}
```

좋은IT기업은 **하나의 목적**을 위해서 동작을 수행합니다.

그 과정에서 많은 행동들이 필요하지만 , 그 메소드들의 책임은 자신이 가지고 있지 않습니다 . 

대신 그 일을 잘 처리해 줄 수 있는 객체들만 알고 있습니다.



우리는 하나하나의 객체에 하나하나의 알맞게 책임을 부여하고 ,  

책임을 수행하는 객체들간의 협력으로 하나의 다른 더 큰 책임을 수행하고 있습니다.

또 그 **객체에게 메시지**를 보내서 행동수행을 요청해서 , **객체들의 협력**을 통해 하나의역할을 제대로 수행하게됩니다.

---

## OCP -개방폐쇠 원칙**(Open-closed principle)**

#### 확장에 개방적이고 , 변경에 폐쇠적이어야한다.

음? 처음에 확장과 변경이 그렇게 다른 것인지 의문을 가졌었다.

일단 확장은 기능의 추가이고 , 변경은 기능구현의 변경이다.

기능을 추가할때는 딱 기능만 추가할 수 있게 , 즉 기존의 다른 부분들에 수정이 필요 없게 , 

기능이 변경이 , 이 기능을 가져다 쓰는 다른 코드들에 영향을 주지않게 해야한다는 것이다.



개발을 접하지 않은 사람들이 보기에 어찌보면 당연하게 들릴 것이다.

기능을 추가하면 기능만 추가 되면 그만이지. 변경되면 변경만 되면 그만이지 라고 생각 할 수 있다 .

이 과정은 생각보다 쉽지 않다 . 하지만 우리는 저 어렵지만 당연한 생각 을 실천해야한다.



####변경에 폐쇠적이려면 어떻게 해야할까?

일단 변경될수 있는 부분과 변경이 안될 부분을 나누어 보자.

일반적으로 인터페이스는 무엇일까?

나는 인터페이스는 변하지 않을 것이라고 외부에게 알려주는 일종의 약속이라고 생각한다.

통용적으로 이해할 수 있는 인터페이스는 UI (User Interface ) 같은 것이 있을 것이다.

<img width="1064" alt="스크린샷 2019-05-18 오후 5 54 04" src="https://user-images.githubusercontent.com/39197978/57967201-bcbbf280-7996-11e9-903c-37e153b8e08d.png">

파란색으로 표시된 영역을 보자 .  아마 이 홈페이지를 처음보는 사람들도 알 수 있을 것이다 .

**IOS_Training** 이라는 파란색글자는 **클릭**시 , 저기와 관련된 어떤 페이지로. **이동**할 것이라는 것을 누가 알려주지 않아도 알 수있다.

또 그 밑에  **꼼꼼한 재은씨 - 실전편 공부** 라고 주황색으로 표시된 부분을 보면 , 클릭시 이동은 하지않고 , 저 노란색으로 감싸진 영역에 대한 **설명** 을 하고 있다는 것을 누가 알려주지 않아도 모두 알 것이다.

이것이 **인터페이스이고 , 이것은 변하지 않는 약속**일 것이다 . 

하지만 페이지가 이동되는 원리에 대해 이 페이지를 보는 사람은 알 필요가 없다.

 또 페이지를 이동하는 원리가 바뀐다해도 , 이동은 무조건 할 것이기 때문에 사용자는 원리에 대해 자세히 알 필요가 없고 , 

누르면 이동한다는 사실만 알면된다.

**여기서 변하지 않는 부분**은 **저 파란색글씨를 누르면 이동할 것**이다라는 약속이다.

**변하는 부분**은 어디일까 ? 브라우저가 **페이지를 이동하는 원리**는 , 기술의 발전에 따라서 더 좋은 성능을 위해 다른 방식을 사용 할 수도있다.  저 원리가 바뀐다고 , 파란색글씨를 누르면 이동한다는 약속을 바뀌지않는다.

위의 예가 바로 변하는 부분과 변하지 않는 부분이 잘 나뉘어있어서 사용자가 혼란스럽지 않은 예라고 생각한다.

코드로도 비슷한 적용이 가능하다.



롤 캐릭터로 설명할 것이니 , 모른다면 한번해보고 마저 읽어보자.



```swift
struct 블리츠크랭크{
    public func 그랩(){
        print("👋")
    }
    public func 전자기장(){
        print("⚡️⚡️⚡️⚡️")
    }
}
```

```swift
// InGame
func 게임하기(내캐릭터: 블리츠크랭크){
    내캐릭터.그랩()
    내캐릭터.정전기장()
}
```

이런 식으로 게임을 하고있다. 

하지만 어느날  업데이트를 통해 캐릭터의 수정에 생겼다.

```swift
struct 블리츠크랭크{
//    public func 그랩(){
//        print("👋")
//    }
    public func 강철주먹(){
        print("👊")
    }
    public func 정전기장(){
        print("⚡️⚡️⚡️⚡️")
    }
}
```

이 수정은 기존의 코드를 부서뜨릴 것이다.

```swift
// InGame
func 게임하기(내캐릭터: 블리츠크랭크){
    내캐릭터.그랩() // 컴파일에러
    내캐릭터.정전기장()
}
```

이것은 `그랩()` 이라는 변경될 수있는 부분을 `public` 으로 만들어둔 개발자의 잘못이다.

변경될 부분을 숨겨두고 , 변경되지 않는 부분만 밖에 노출시켜줘야하는 데 , 그걸 어긴 대가는 이런 코드의 수정을 야기한다.



인터페이스 즉 - 변하지 않을 부분을 분리해보자

```swift 
protocol 롤캐릭터 {
    func Q()
    func R()
} // 롤캐릭터가 무조건 해야하는 약속 / 변경될 수 없는 부분
```

```swift
struct 블리츠크랭크: 롤캐릭터 {
    public func Q() {  
        그랩() 
    }
    
    public func R() {
        정전기장()
    }
    
    private func 그랩(){   
        print("👋")
    }

    private func 정전기장(){
        print("⚡️⚡️⚡️⚡️")
    }
}
```

코드의 양이 늘어났다.  여기서 주목해야할 것은 변하지 않을 부분과 변하는 부분을 나누었고 , 그에따른 접근제한자 또한 그에 맞게 설정 되었다는 것이다.

변하지 않을 부분에 대해서는 protocol 이라는 외부와의 약속으로 분리했고 , 변하는 부분에 대해서는 `private` 로 외부에서 모르게 만들어 주었다 . 

<img width="442" alt="스크린샷 2019-05-18 오후 6 38 26" src="https://user-images.githubusercontent.com/39197978/57967612-2d194280-799c-11e9-849b-4320f77d53cb.png">

이렇게 외부에서는 약속해둔곳 ( 변하지 않을 부분 ) 만 알 수있고 , 변할 부분은 모르게 되었다.

 ```swift
struct 블리츠크랭크: 롤캐릭터 {
    public func Q() {
        강철주먹()
    }
    
    public func R() {
        정전기장()
    }
    
//    private func 그랩(){
//        print("👋")
//    }
    private func 강철주먹(){
        print("👊")
    }

    private func 정전기장(){
        print("⚡️⚡️⚡️⚡️")
    }
}
 ```

이렇게 패치를 통해 스킬이 변경된 다고 해도 ,  위처럼 코드가 고장나지는 않는다 .

약속한 메시지를 보내면 , 구현부가 달라져서 다른 구현을 할 뿐 이다. 

이렇게 **변하지 않는 부분과 변하는 부분을 나눔으로써 , 변경에 폐쇠적**이게 되었다.

그런 데 또 이번에는 캐릭터가 추가가 되었다.

```swift
struct 티모: 롤캐릭터 {
    public func Q() {
        맹독다트()
    }
    
    public func R() {
        버섯함정()
    }
    
    private func 맹독다트(){
        print("🧪")
    }
    
    private func 버섯함정(){
        print("🍄")
    }
}
```

 ```swift
func 게임하기(내캐릭터: 블리츠크랭크){
    내캐릭터.Q()
    내캐릭터.R()
}
 ```

캐릭터가 추가됨에 따라서 위의 게임하기 메소드의 수정이 필요할 것으로 보인다.

티모로는 게임을 할 수가 없으니까 .

이것은 확장에 대해 개방적이어야 하는 원칙에 어긋난 것이다 .

너무 구체적인 타입에 의존해서 생긴 문제가 되겠다.

```swift
func 게임하기(내캐릭터: 롤캐릭터){
    내캐릭터.Q()
    내캐릭터.R()
}
```

위처럼 바꿈으로서 , 조금더 유연한 확장이 가능해졌다.

이건 무조건 적인 확장이 아니다. **약속을 지키고 있는 누구나** 들어와도 된다는 것이다.

그렇다면 확장은 **약속을 지키는 확장에 대해서는 개방적**이게 된 것이다 .

처음보다 훨씬 더 유연해지고 확장에 개방적이고 내부**구체적인것의 수정에 폐쇠적**으로 보인다.

----

## LSP - 리스코프 치환 원칙 (**Liskov substitution principle**) 

### 자식클래스 (서브클래스) 는 부모클래스(슈퍼클래스)의 역할을 완벽히 수행할 수 있어야한다.

호오 당연한 얘기 아닌가?

'새'를 상속받은 '부엉이는 '새'로써의 역할을 완벽히 해야한다.  

맞는 말인데 이게 좀 처럼 지켜지지 않는다.

이 문제는 서브클래스가 슈퍼클래스의 메소드를 **Override**  하는 과정에서 발생한다.

```swift
class 초시계 {
    var 초:Int = 0
    
    func 시간이흐르다(){
        초 = 초 == 59 ? 0 : 초 + 1
    }
    func 시간보여주기(){
        print("\(초)초")
    }
}
```

초시계를 만들어 보았다.

근데 `초시계`의 동작을 모두 수행하면서 분까지 보고싶은 마음에 , `분초시계`라는 것을 만들었다.

```swift
class 잘못된분초시계: 초시계{
    var 분:Int = 0
    
    override func 시간이흐르다(){
        super.시간이흐르다()
        if(초 == 59){
            분 += 1
        }
    }
    
    override func 시간보여주기(){
        print("\(분)분")
        super.시간보여주기()
    }
}
```

분초시계를 만드는 과정에 , 초시계로서의 역할을 재사용 하기위해서 상속을 받았다.

문제가 없어 보인다.  하지만

```swift
let 어떤초시계 : 초시계 = 분초시계()
let 잘못된초시계: 초시계 = 잘못된분초시계()

for _ in 0...65{
어떤초시계.시간보여주기()   // *분*초
어떤초시계.시간이흐르다()
}
```

??? 분명히 초시계인데 분까지 보여준다 .  나는 분명히 초시계를 사용하기 위해서 사용했지만 이상하게도 이 오브젝트는 엉뚱한 동작을 한다.

분초시계는 초시계로서의 역할을 하면서 추가적인 확정적인 동작을 하는 것이지 , 기존 초시계 의 동작을 잃어버려서는 안된다. 

만약 잃어버리게 해야한다면 , 이것은 상속이 올바른 구조인지 한번 더 생각해 보아야한다.

```swift
class 분초시계: 초시계{
    var 분:Int = 0
    
    override func 시간이흐르다(){
        super.시간이흐르다()
        if(초 == 59){
            분 += 1
        }
    }
    
    func 분보여주기(){
        print("\(분)분")
    }
    
    func 분초보여주기(){
        self.분보여주기()
        super.시간보여주기()
    }
}
```

이렇게 추가적인 확장이 올바른 것이다.

LSP를 지키는 가장 간단한 방법은 Override를 안하는 방법이다.

맞는 말이지만 , 가장 간단한 방법이지  , 무조건 적인건 아니다.

위의 예에서 , 시간이흐르다() 라는 메소드는 Override 를 했음에도 불구하고, 올바르게 부모클래스로서의 역할을 수행하고있다.

부모클래스의 메소드 super.시간이흐르다() 를 올바르게 수행하고 , 그후에 **상속에서 추가된 프로퍼티에 대해서만 처리**를 했기때문에 , 

예상하지 못한 동작을 하지 않는다.

#### LSP를 지키는 방법은 재정의를 할때는 정말 신중히 고민을 하고 , 올바른 상속을 하면 지킬 수 있다 고 생각한다.

---



## DIP - 의존관계 역전법칙(Dependency inversion Principle)

#### 추상화 된 것은 구체적인 것에 의존하면 안되고 구체적인 것이 추상화된 것에 의존해야 한다
위에서는 **변할수 있는것**  과 **변하지 않을 것** 을 나누는 게 중요했다.

그리고 **구체적일 수록 잘 변했고** , **구제적이지 않을 수록 잘 변하지 않았다.**



객체사이의 서로 도움을 주고 받으면서 협력을 하게 되면  어쩔수 없이 의존관계가 생길 수밖에 없다.

```swift
struct 평범한움직임{
    func 이동하다() {
        print("🐾")
    }
    
    func 점프하다() {
        print("💨")
    }
}
```

```swift
struct 고양이 {
    let 움직이는전략: 평범한움직임  // 구체 클래스
    
    func 이동하기(){
        움직이는전략.이동하다()
    }
    
    func 점프하기(){
        움직이는전략.점프하다()
    }
}
```

위의 예제와 비슷하겠지만 , `고양이` 는구체적인 `평범한움직임`이라는 구조체에 의존하고있다. 구체적인 클래스는 변화에 취약하다.

그 과정에서 **의존성을 역전** 시키기위 한 방법은 **의존하는 클래스를 덜 구체적인 클래스**로 하는 것이다. 

```swift
protocol 움직이는방법 {
    func 이동하다()
    func 점프하다()
}
/
struct 평범한움직임: 움직이는방법{
    func 이동하다() {
        print("🐾")
    }
    
    func 점프하다() {
        print("💨")
    }
}
```

변하지 않을 부분을 선언해둠으로써 , 구체적인 타입을 포함할 수 있게 추상적인 타입을 선언해보자



```swift
struct 고양이 {
    let 움직이기전략: 움직이는방법  // 구체적이지 않은 클래스에 의존
    
    func 이동하기(){
        움직이기전략.이동하다()
    }
    
    func 점프하기(){
        움직이기전략.점프하다()
    }
  //DI - 의존성주입
  mutating	func 움직이는방법바꾸기(_ 새로운움직이기전략:움직이는방법){
      self.움직이기전략 = 새로운움직이기전략
    }
}
```

이렇게 구체적이지 않은 타입으로 바뀌면서 의존하는 클래스를 외부에서도 쉽게 넣어줌으로써 , 

런타임에서도 동작을 변경시킬수 있는 유연한 코드가 되었다.

```swift
struct 재빠른움직임: 움직이는방법{
    func 이동하다() {
        print("🐾🐾🐾🐾🐾🐾")
    }
    
    func 점프하다() {
        print("💨💨💨💨💨💨")
    }
}
```

```swift
let 🐈 = 고양이()
🐈.움직이는방법바꾸기(평범한움직임())
🐈.이동하기() //  Print 🐾
🐈.움직이는방법바꾸기(재빠른움직임())
🐈.이동하기() //  Print 🐾🐾🐾🐾🐾🐾
```

이렇게 추상적인 타입에 의존하게 됨으로써 , **의존성주입**을 통한 유연한 코드도 가능해졌다.

의존성역전을 통해 의존성주입이라는 이점을 취할수 있게 된 예이다.

####위의 예시는 **''스트래티지패턴''** 을 이용했다 . 공부해보자



---

## ISP- 인터페이스 분리 법칙 (Interface segregation principle)

####클래스 내에서 사용하지 않는 인터페이스는 구현하지 말아야 한다.

고양이가 잘 이동하고 있다 .

강아지도 추가해서 , 이쁘게 움직이게 만들어 주었다.



그런데 어느날 '달팽이'가 필요해졌다.

```swift
struct 달팽이(){
    let 움직이기전략: 움직이는방법  // 구체적이지 않은 클래스에 의존
    
    func 이동하기(){
        움직이기전략.이동하다()
    }
  //DI - 의존성주입
    mutating func 움직이는방법바꾸기(_ 새로운움직이기전략:움직이는방법){
      self.움직이기전략 = 새로운움직이기전략
    }
}
```

```swift
struct 점프못하는느린움직임: 움직이는방법 {
    func 이동하다() {
         print("~")
    }
    
    func 점프하다() {
         ()
    }
}
```

```swift
let 🐌 = 달팽이(점프못하는느린움직임())
```

달팽이 는 안타깝게도 점프를 못하는 아이 이다.

그래서 점프를 못하는 움직임이 필요해졌다.

그과정에서 이전과 같이 `움직이는방법`  이라는 프로토콜을 채택했고 , 필요없는 `점프하다` 라는 메소드를 구현을 텅비게 하였다.

<img width="570" alt="스크린샷 2019-05-18 오후 9 07 51" src="https://user-images.githubusercontent.com/39197978/57969341-06193b80-79b1-11e9-9037-c06047144314.png">

하지만 외부에서 달팽이는 점프하기를 할수있는 객체로 보고있다.

점프를 하게해보면 아무동작은 안하는 걸 알 수 있겠지만 , 그걸 실행해보기 전까진 알 수 없다.

이런 방법은 **클래스의 응집도가 떨어뜨리게 된다** . 달팽이라는 아이는 달팽이와 관련된 동작과 상태로 가득가득해야하는데 . 쓸모없고, 관계도 없는 동작이 들어가게되면서 , 응집도가 낮아진 것이다.



**왜 이런 일이 일어났을까?**

하나의 프로토콜을 채택하는 순간 그에 부수적인 많은 것들을 다 강요 받기 때문이다.

패스트푸드점이 있다.

M 사 는 단품(🍔), 콜라(🥤), 감자튀김(🍟) , 세트(🍔🍟🥤) 이런 선택지가 있다. 

L 사는  세트(🍔🍟🥤) 라는 단일 선택지가 있다.

세트를 먹기 위한 사람은 어디를 가던지 상관없지만, 감자튀김이나 콜라를 싫어하는 사람에게는 M사가 더 구미가 댕길 것이다.

 // 나는 감자튀김을 싫어하기때문에 L사 안갈것같다.

감자튀김을 먹기싫어하는 사람은 세트를 사면서 , 쓸데없는 것을 얻게 된다.



이것에 대한 해결로는 M사 가 했듯이 , 각각을 분리해서 두고 , 합쳐서도 판매 한다면 , 필요한 것만 쏙쏙 쓸수도 있게 될 것이다.



이 방법으로 달팽이를 좀 더 달팽이 답게 바꿔보자.

```swift
protocol 점프하는방법 {
    func 점프하다()
}
protocol 이동하는방법 {
     func 이동하다()
}
typealias 움직이는방법 = 점프하는방법 & 이동하는방법
```

`움직이는방법`을  `이동하는방법, 점프하는방법` 으로 분리해 냈다.

```swift

struct 점프못하는느린움직임: 이동하는방법 {
    func 이동하다() {
        print("~")
    }
}
```

이렇게 분리하게 되니 쓸데없는 구현이 없는 움직임방법이 생겼다.

```swift
struct 달팽이 {
    var 이동방법: 이동하는방법
    
    func 이동하기(){
        이동방법.이동하다()
    }
    mutating func 움직이는방법바꾸기(_ 새로운이동방법:이동하는방법){
        self.이동방법 = 새로운이동방법
    }
}
```

그리고 달팽이도 온전히 달팽이 답게 움직일수 있게 되었다.

 DIP과정에서 추상적인 부분을 분리해 내면서 , 의도하지는 않았지만 , Interface 가 커지는 것을 경험했을 것이다.

하지만 **Interface가 크다는 것은 한번에 지켜야 할 약속이 너무 많아진 다는 것**이다 .

커진 인터페이스에서 적당한 동작으로 구분해내야한다.

한 인터페이스당 하나만 메소드를 구현하면 무조건 좋을거같은데?  그러면 , 그걸 조합해 나가면 다 되지 않을까?

꼭 작아야하는 건 아니다. 적당히 작아야한다.



### 다시 햄버거 가게로 가보자

M 사 는 단품(🍔), 콜라(🥤), 감자튀김(🍟) , 세트(🍔🍟🥤) , 추가로 쿠키(🍪) 를 팔게 되었다.

쿠키는 특별히 100원 에  판매한다 .

대신 세트를 구매한 사람에 한해서 판매한다.

이런 경우 ,  쿠키를 사기위해서는 다른 100원을 내는 약속 + 세트를 구매한다는 약속 

 이 두가지가 강요되어진다 .

이런 경우에는 묶어둠으로써 , 약속을 강제적으로 지키게 만들어야할 필요가 있는 것이다.



# 이상 SOLID 원칙 이었습니다.

