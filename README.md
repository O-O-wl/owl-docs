# O-O-wl 's Standard  🦉📖

---

나만의 기준을 찾아가는 중

---

#### 고쳐야할 문제점
 - 의문이 드는 것에 대한 탐색은 하나, 당연하지 않을 걸 당연하게 생각하는 게 꽤 있고, 그래서 궁금증조차 가지지 않는 경우가 많다
 - 좋다고 한 번 느끼면 꽤나 맹신한다.
 - 여러 선택지에서 좋는 답을 찾을 때, 감각에 의존하거나 이전에 비슷한 사례를 보고 결정을 하나, 그 사례에서 왜 이런 선택을 했는 지가 명확하지 않은 적이 많다 
<br>

<br>

## 나의 기준

---

- #### 클래스

<br>

- #### 열거형

  - 클래스내에 nested enum으로 정의하는 경우 - 확장 또는 프로퍼티 위에 위치하게 하자. 
    - 케이스가 5개 이상인  enum일 경우 확장을 하자.
  - 제한된 갯수의 케이스만 존재할 경우 enum 을 생각해보자
  - 

<br>

- #### 구조체

<br>

- #### 프로토콜

<br>

- #### 익스텐션
  - 기본 자료형을 핸들링하는 메소드가 어떤 객체에서 필요하나, 객체내부에 구현하면 응집도가 떨어지는 경우 고려해볼 수 있다.
  - 여러 뷰 컨트롤러에서 설정해야하는 반복적인 셋업함수를 extension으로 하면 반복을 줄일수있다.

<br>

- #### 제네릭

<br>

- #### 옵셔널

  - **강제 옵셔널 언래핑**은 변수에서는 사용하지 말자. 상수 또는 하드코딩된 보장할 수있는 값 에서만 사용하자.

  - ``` 
    변수는 어디서 값이 정해지는 지 또 어디서 변하는 지 모호하다. 상수로 된 값이나 리터럴은 이걸 보장할 수 있다.
    ```

  - 옵셔널이 아닌 무조건 존재해야하는 값을 옵셔널로 하는 걸 기피하자.

  - ```
    옵셔널 이라는 건 값이 존재할 수 있고 아닐 수 있다는 걸 의미한다. 그 말은 언옵셔널한 데이터는 무조건 값이 존재한다는 걸 의미한다. 무조건 값이 존재한다는 건 데이터의 무결성을 보여주는 것이다. 
    무결함을 보여야 할 객체와 nilable 한 객체를 확실히 구분하기 위해 노력하자.
    ```

  - **IUO** 언제 사용??
  
    - 일반 옵셔널과 목적이 다르다. 꼭 준비되야한다는 의도를 표현할 수있다.
    - 상위 모듈의 생성시에는 초기화 안될수 있지만, 사용시에는 꼭 초기회되야한다는 걸 명시할 수있다.
    - 

<br>

---

<br><br>

## 나쁜 습관과 피해야할 코드

---



- - - 

  <br>

- ### 클래스

  - 내부에서 다른 클래스와 구조체의 생성자를 호출하지말자

    ```
    생성자는 구체적인 타입에 의존하는 코드이고, 외부에 의존성이 숨어서 테스트도 힘든 구조가 된다.
    ```

  
  - 이름 문제
    - VO같은 특징다운 이름을 iOS에서는 지양한다./ 목적에 맞는 이름을 쓰자.

<br>

<br>

## 고민해야 하는 문제

---

- #### `computed property` vs `method`


<br>

- #### `struct` vs `class`




<br>

- #### `if`  vs `guard` 


<br>

-  #### 의존성 방향 설정하기

   - `클래스A(보호수준이 높아야하는)` / `클래스B` 간의 협력을 위해서는 의존성이 생긴다.
   - 더 변화로 부터 보호해야할 클래스는 다른 클래스에 의존을 최대한 안하게 만들어야한다.

   - **보호 수준이 높아야하는 `클래스 A`** **에 `클래스 B`를 의존하게 하는 것**이, 이후의 변화에 따른 고장에 더 안전할 수 있다.

<br>

- #### 객체내 타입 표현 vs 익스텐션을 통한 타입 표현

<br>

- #### `lazy property`  vs `eager property`

  - 해당 프로퍼티의 사용이 무조건적이지 않다면  `lazy`를 고민해보자
  - 객체를 생성하는 데 걸리는 오버헤드가 존재한다.  **객체가 쓰일 상황에 즉각적인 응답을 원한다면  `lazy`를 사용하지말자**

  <br>
- #### `다양한 인스턴스` vs `클래스의 상속`

  - 상위 클래스에서 모든 인스턴스를 표현하는 속성이 아니라면 특수화된 서브클래스를 만들자.

<br>

- ### 자료구조 선택
  - 튜플
    - 각 엘리먼트간의 강한 결합이 아닌 느슨한 결합(비교적 연관도가 적은느낌)이다. 그에 부합하는 경우
    - 여러 컴포넌트에 걸쳐 사용되는 것이 아닌, 그 영역내에서 임시적으로 묶는 다는 느낌이 있음.

<br>

- ####  `Enum` vs `Protocol`

  - 타입의 추가가 있을 상황? - **프로토콜**
    - 열거형은 `case` 가 추가되면 `switch` 문이 모두 고장나버리고 만다.
  - 함수의 추가가 지속적으로 있을 상황? - **열거형**
    - 함수의 추가가 있을 때, 프로토콜을 채택한 타입의 고장나고, 메소드의 구현이 요구된다.

<br>

- #### `throw Error` vs `optional`

  - **옵셔널**은 `nil 가능성을 의미한다`. 대신 nil의 이유를 표현하지는 않는다.

    - 옵셔널로 표현할 떄는 **클라이언트가 nil이 반환된 이유를 명확히 알 수있어야한다**. - 이유가 1개여야?
    - 만약 여러개의 이유로 nil이 반환된다면 옵셔널 보다는 Error로 실패이유를 설명하자
  - **Error Throw** 는 심각한 위험을 표현한다
    - 기존에 정상적인 흐름과는 다른 흐름으로 흐름제어가 일어나야하는 경우가 생긴다.
    - 또 디테일한 실패의 이유를 볼수 있다.
    - **실패의 이유가 많을 경우 클라이언트는 실패의 이유를 알려야한다.**

  <br>
  
  #### `Tuple` vs `DTO`
  
  - 튜플 내부의 속성이 중첩적으로 계층적인가?
  
    - 그렇다면 DTO가 적절할 수 있다. 
  
    - 튜플은 좀 느슨한 (응집되지 않은)느낌 + 딱 거기만 사용하도록 제한한 느낌이 있어요(DTO처럼 전달되는 느낌이 아님)  
      좀더 구체적인 타입이 아닌 것 같아서요  
      DTO 용도 타입이라면 튜플 보다 명확할 것 같았어요
  
    - 튜플은 관련된 값들을 임시로 그룹지어 두어야 할 때 유용합니다. … 데이터 구조가 이런 임시적인 범위를 넘어서 영구적으로 사용할 필요가 있다면 클래스나 구조체로 정의해야합니다
  
      <br>
  
- #### `DispatchQueue` vs `OperationQueue`

  - **`DispatchQueue`**

    - 성능이 더 좋으므로 성능이 우선시 될 때
    - 일단 Dispatch되고나면 실행이 보장됨 -> 중도 컨트롤이 어려움
    - 사소한 작업시 `Operation`의 서브클래스를 만들지 않아도 되는 장점이 존재
    - 저수준의 API

  - **`OperationQueue`**

    - 작업의 순서를 커스텀해야할 때
    - KVO를 통해 작업의 정도(진행상태)를 알수 있다.
    - Pause/ resume / cancel 이 가능함
    - 동시에 수행될 연산의 최대수 를 제어할 수 있다.
    - 순차적인 기능의 블럭을 캡슐화 하기 좋다.

    <br>

- ####  `Notification` vs `Delegation` vs `KVO`

  ​	

   <br>

---

## 혼자만의 생각 정립하기

- #### 캡슐화 왜 해야돼?

  - 데이터와 연산을 모아야 코드의 응집력이 생긴다.
  - 데이터를 뮤테이션하는 건 오퍼레이터에서만 하게하자 - 객체는 자율적이기에 객체에 메시지를 보내서 해야한다.
    - 데이터를 처리하는 방법은 오퍼레이션으로 제한하자.
    - 데이터는 적극적으로 감추자 - 데이터 은닉, 가시성
  - 왜 뭉쳐야하는가? 외부에서 직접 접근 못하게 하는 대
