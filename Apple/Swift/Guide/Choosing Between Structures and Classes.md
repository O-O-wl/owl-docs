# Choosing Between Structures and Classes

---

> 데이터와 모델의 행동을 저장하는 법을 정하자
>
> ---



<br>

<br>

### Overview

---

구조체와 클래스는 앱 내에서 행동을 만들고 데이터를 저장하는 좋은 선택지이다.

그러나 이 둘의 유사성때문에 선택이 어렵다



새로운 데이터 타입을 앱내에 추가할 때, 아래의 사항을 고려해보자

- 기본적으로는 구조체를 사용하자
- Objective-C 와의 상호작용이 필요하다면, 클래스를 사용하자
- 모델링하는 데이터의 식별자를 제어할 필요가 있다면, 클래스를 사용하자
- 구현을 공유함으로써, 프로토콜을 채택하여 구조체를 사용하자

<br>

---

<br><br>

### Choose Structures by Default

---

데이터의 종류를 표현하기 위해서는 구조체를 사용하자.

Swift의 구조체는 다른 언어에서는 클래스에 한정된 기능( 저장 프로퍼티, 메소드, 계산 프로퍼티 등등...)을 포함한다.

게다가, Swift의 구조체는 프로토콜을 채택할 수 있다. 우리가 사용하는` numbers, strings, arrays, dictionaries` 가 모두 구조체로 되어있다.

<br>

구조체를 사용하면 앱의 상태를 고려할 필요 없이 쉽게 코드의 일부에 대해 판단할 수 있다.

그 이유는 구조체는 값 타입이다. 그래서 앱의 다른 흐름의 변화에 영향을 받지 않을 수 있다.

그래서, 코드의 일부만 볼 수 있다.

<br>

---

<br><br>

### Use Classes When You Need Objective-C Interoperablity

---

만약 데이터 처리에서 Objective-C API 를 사용해야 한다면,  클래스를 사용하자. 

대부분의 Objective-C 프레임 워크는 서브클래스를 위한 클래스들을 사용한다.

<br>

---

<br><br>

### Use Classes When You Need to Control Identitiy

---

클래스는 레퍼런스 타입이라서 식별자, 동일성이라는 개념이 내포 되어있다.

이것은 두개의 다른 클래스 인스턴스가 프로퍼티로 같은 값을 가진 경우, `===` 를 통해 서로가 다름을 알아낼 수있다.

이 말은 해당 인스턴스의 변경사항이 인스턴스를 참조하는 모든 코드에 반영 된다는 걸 의미한다.

식별자를 가져야하는 인스턴스를 필요로 할 때, 클래스를 사용하면 된다.

일반적으로는 파일핸들링, 네트워크 커넥션과 같은 케이스들이 존재한다.

```
Important

식별자는 조심히 다뤄야한다. 클래스 인스턴스를 앱의 곳곳에서 공유하는 것은 에러를 만들 수 있다.
많이 공유되는 인스턴스의 변화의 결과를 에측하는 행동을 자제하자.
```

<br>

------

<br><br>

### Use Structure When You Don't Control Identity

---

제어하지 않는 ID를 가진 엔터티에 대한 정보가 포함 된 데이터를 모델링 할 때 구조체를 사용하십시오.

예를 들어 원격 데이터베이스를 참조하는 앱에서 인스턴스의 ID는 외부 엔터티가 완전히 소유하고 식별자로 통신 할 수 있습니다. 앱 모델의 일관성이 서버에 저장된 경우 식별자가있는 구조로 레코드를 모델링 할 수 있습니다. 아래 예에서 `jsonResponse`에는 서버의 인코딩 된 `PenPalRecord` 인스턴스가 포함되어 있습니다.

```swift
struct PenPalRecord {
    let myID: Int
    var myNickname: String
    var recommendedPenPalID: Int
}

var myRecord = try JSONDecoder().decode(PenPalRecord.self, from: jsonResponse)

```

`PenPalRecord`와 같은 모델 유형에 대한 로컬 변경이 유용합니다. 예를 들어, 앱은 사용자 의견에 따라 여러 개의 다른 펜팔을 추천 할 수 있습니다. `PenPalRecord` 구조체는 기본 데이터베이스 레코드의 ID를 제어하지 않기 때문에 로컬 `PenPalRecord` 인스턴스의 변경으로 인해 데이터베이스의 값이 실수로 변경 될 위험이 없습니다.

앱의 다른 부분이 `myNickname`을 변경하고 변경 요청을 서버에 다시 제출하면 가장 최근에 거부 된 펜팔 추천이 변경으로 인해 잘못 선택되지 않습니다. `myID` 속성은 상수로 선언되므로 로컬로 변경할 수 없습니다. 결과적으로 데이터베이스에 대한 요청은 실수로 잘못된 레코드를 변경하지 않습니다.

<br>

------

<br><br>

### 

### Use Structures and Protocols to Model Inheritance and Share Behavior

---

구조체 와 클래스는 모두 상속 형태를 지원합니다.

 구조체는 프로토콜 만 채택 할 수 있습니다. 구조체는 클래스를 상속받을 수 없습니다. 

처음부터 상속 관계를 구축하는 경우 프로토콜 상속을 우선시하자.

 프로토콜은 클래스, 구조체 및 열거형 모두 상속을 허용한다.

하지만, 클래스 상속은 클래스만 해당된다.



